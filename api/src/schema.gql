type Query {
  # client api
  getRoomById(id: ID!): Room
  getRoomByTag(tag: String!): Room
  getPlayerById(id: ID!): Player

  # information about fictionary
  rooms(input: listRoomsInput, first: Int, last: Int, after: String, before: String): RoomConnection
  players(input: listPlayersInput, first: Int, last: Int, after: String, before: String): PlayerConnection
}

type Mutation {
  createRoom(tag: String!): Room
  createPlayer: Player
  addPlayerToRoom(roomid: ID!, userid: ID!): Room
}

type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String!
  endCursor: String!
}

type RoomConnection {
  edges: [RoomEdge]
  pageInfo: PageInfo!
}

type RoomEdge {
  node: Room
  cursor: String!
}

type PlayerConnection {
  edges: [PlayerEdge]
  pageInfo: PageInfo!
}

type PlayerEdge {
  node: Player
  cursor: String!
}

type Player {
  _id: ID
  tag: String!
  color: String!
  overallScore: Int
}

input listPlayersInput {
  id: stringFilterInput
  tag: stringFilterInput
  color: stringFilterInput
  overallScore: intFilterInput
}

type DefinitionTuple {
  id: ID!         # id of proposer
  value: String!  # definition
}

type VoteTuple {
  id: ID!         # id of voter
  proposerid: ID! # id of proposer to which the vote goes
}

type ScoreTuple {
  id: ID!         # id of player
  score: Int!     # score of the player
}

enum WordState {
  OPEN
  VOTING
  CLOSED
}

type Word {
  authorid: ID! # the author's id is used to find the 'true' definition
  voters: [ID!]!
  definitions: [DefinitionTuple!]!
  votes: [VoteTuple!]!
  state: WordState!
}

type Room {
  _id: ID
  tag: String!
  players: [Player!]!
  words: [Word!]!
  scores: [ScoreTuple!]!
}

input listRoomsInput {
  id: stringFilterInput
  tag: stringFilterInput
}

input stringFilterInput {
  eq: String
  # regex: String
}

input intFilterInput {
  eq: Int
  gt: Int
  gte: Int
  lt: Int
  lte: Int
}
